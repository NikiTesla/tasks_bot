// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChat = `-- name: AddChat :exec
INSERT INTO chats (chat_id, username, phone, role) VALUES ($1, $2, $3, $4) ON CONFLICT (chat_id)
DO UPDATE SET username = COALESCE(NULLIF(EXCLUDED.username, ''), chats.username), phone = COALESCE(NULLIF(EXCLUDED.phone, ''), chats.phone)
`

type AddChatParams struct {
	ChatID   int64       `json:"chat_id"`
	Username pgtype.Text `json:"username"`
	Phone    pgtype.Text `json:"phone"`
	Role     pgtype.Int4 `json:"role"`
}

func (q *Queries) AddChat(ctx context.Context, arg *AddChatParams) error {
	_, err := q.db.Exec(ctx, addChat,
		arg.ChatID,
		arg.Username,
		arg.Phone,
		arg.Role,
	)
	return err
}

const addTask = `-- name: AddTask :one
INSERT INTO tasks (title, executor_contact, executor_chat_id, deadline, done, closed, expired) VALUES ($1, $2, $3, $4, false, false, false) RETURNING id
`

type AddTaskParams struct {
	Title           string           `json:"title"`
	ExecutorContact string           `json:"executor_contact"`
	ExecutorChatID  pgtype.Int8      `json:"executor_chat_id"`
	Deadline        pgtype.Timestamp `json:"deadline"`
}

func (q *Queries) AddTask(ctx context.Context, arg *AddTaskParams) (int64, error) {
	row := q.db.QueryRow(ctx, addTask,
		arg.Title,
		arg.ExecutorContact,
		arg.ExecutorChatID,
		arg.Deadline,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const changeTaskDeadline = `-- name: ChangeTaskDeadline :exec
UPDATE tasks SET deadline = $2, expired = false WHERE id = $1
`

type ChangeTaskDeadlineParams struct {
	ID       int64            `json:"id"`
	Deadline pgtype.Timestamp `json:"deadline"`
}

func (q *Queries) ChangeTaskDeadline(ctx context.Context, arg *ChangeTaskDeadlineParams) error {
	_, err := q.db.Exec(ctx, changeTaskDeadline, arg.ID, arg.Deadline)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTask, id)
	return err
}

const getAllTasks = `-- name: GetAllTasks :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks
`

func (q *Queries) GetAllTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getAllTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChat = `-- name: GetChat :one
SELECT chat_id, username, phone, role, stage, created_at FROM chats WHERE username = $1 OR phone = $2
`

type GetChatParams struct {
	Username pgtype.Text `json:"username"`
	Phone    pgtype.Text `json:"phone"`
}

func (q *Queries) GetChat(ctx context.Context, arg *GetChatParams) (*Chat, error) {
	row := q.db.QueryRow(ctx, getChat, arg.Username, arg.Phone)
	var i Chat
	err := row.Scan(
		&i.ChatID,
		&i.Username,
		&i.Phone,
		&i.Role,
		&i.Stage,
		&i.CreatedAt,
	)
	return &i, err
}

const getClosedTasks = `-- name: GetClosedTasks :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks WHERE closed = true
`

func (q *Queries) GetClosedTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getClosedTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoneTasks = `-- name: GetDoneTasks :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks WHERE done = true
`

func (q *Queries) GetDoneTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getDoneTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredTasks = `-- name: GetExpiredTasks :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks WHERE expired = true
`

func (q *Queries) GetExpiredTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getExpiredTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredTasksToMark = `-- name: GetExpiredTasksToMark :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks WHERE done = false AND expired = false AND deadline < (NOW() AT TIME ZONE 'UTC-3') FOR UPDATE
`

func (q *Queries) GetExpiredTasksToMark(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getExpiredTasksToMark)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObservers = `-- name: GetObservers :many
SELECT chat_id, username, phone, role, stage, created_at FROM chats WHERE role = 2
`

func (q *Queries) GetObservers(ctx context.Context) ([]*Chat, error) {
	rows, err := q.db.Query(ctx, getObservers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ChatID,
			&i.Username,
			&i.Phone,
			&i.Role,
			&i.Stage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenTasks = `-- name: GetOpenTasks :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks WHERE closed = false
`

func (q *Queries) GetOpenTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getOpenTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT role FROM chats WHERE chat_id = $1
`

func (q *Queries) GetRole(ctx context.Context, chatID int64) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getRole, chatID)
	var role pgtype.Int4
	err := row.Scan(&role)
	return role, err
}

const getStage = `-- name: GetStage :one
SELECT stage FROM chats WHERE chat_id = $1
`

func (q *Queries) GetStage(ctx context.Context, chatID int64) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getStage, chatID)
	var stage pgtype.Int4
	err := row.Scan(&stage)
	return stage, err
}

const getTaskInProgress = `-- name: GetTaskInProgress :one
SELECT chat_id, title, executor_contact, executor_chat_id, deadline, created_at FROM tasks_in_progress WHERE chat_id = $1
`

func (q *Queries) GetTaskInProgress(ctx context.Context, chatID int64) (*TasksInProgress, error) {
	row := q.db.QueryRow(ctx, getTaskInProgress, chatID)
	var i TasksInProgress
	err := row.Scan(
		&i.ChatID,
		&i.Title,
		&i.ExecutorContact,
		&i.ExecutorChatID,
		&i.Deadline,
		&i.CreatedAt,
	)
	return &i, err
}

const getUserTasks = `-- name: GetUserTasks :many
SELECT id, title, executor_contact, executor_chat_id, deadline, done, closed, expired, created_at FROM tasks WHERE executor_contact = $1
`

func (q *Queries) GetUserTasks(ctx context.Context, executorContact string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getUserTasks, executorContact)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ExecutorContact,
			&i.ExecutorChatID,
			&i.Deadline,
			&i.Done,
			&i.Closed,
			&i.Expired,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpiredTask = `-- name: MarkExpiredTask :execrows
UPDATE tasks SET expired = true WHERE id = $1
`

func (q *Queries) MarkExpiredTask(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, markExpiredTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markTaskAsClosed = `-- name: MarkTaskAsClosed :execrows
UPDATE tasks SET closed = true WHERE id = $1
`

func (q *Queries) MarkTaskAsClosed(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, markTaskAsClosed, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markTaskAsDone = `-- name: MarkTaskAsDone :execrows
UPDATE tasks SET done = true WHERE id = $1
`

func (q *Queries) MarkTaskAsDone(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, markTaskAsDone, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setRole = `-- name: SetRole :exec
UPDATE chats SET role = $2 WHERE chat_id = $1
`

type SetRoleParams struct {
	ChatID int64       `json:"chat_id"`
	Role   pgtype.Int4 `json:"role"`
}

func (q *Queries) SetRole(ctx context.Context, arg *SetRoleParams) error {
	_, err := q.db.Exec(ctx, setRole, arg.ChatID, arg.Role)
	return err
}

const setStage = `-- name: SetStage :exec
UPDATE chats SET stage = $2 WHERE chat_id = $1
`

type SetStageParams struct {
	ChatID int64       `json:"chat_id"`
	Stage  pgtype.Int4 `json:"stage"`
}

func (q *Queries) SetStage(ctx context.Context, arg *SetStageParams) error {
	_, err := q.db.Exec(ctx, setStage, arg.ChatID, arg.Stage)
	return err
}

const setTaskInProgressDeadline = `-- name: SetTaskInProgressDeadline :exec
INSERT INTO tasks_in_progress (chat_id, deadline) VALUES ($1, $2) 
ON CONFLICT (chat_id) DO UPDATE SET deadline = EXCLUDED.deadline
`

type SetTaskInProgressDeadlineParams struct {
	ChatID   int64            `json:"chat_id"`
	Deadline pgtype.Timestamp `json:"deadline"`
}

func (q *Queries) SetTaskInProgressDeadline(ctx context.Context, arg *SetTaskInProgressDeadlineParams) error {
	_, err := q.db.Exec(ctx, setTaskInProgressDeadline, arg.ChatID, arg.Deadline)
	return err
}

const setTaskInProgressName = `-- name: SetTaskInProgressName :exec
INSERT INTO tasks_in_progress (chat_id, title) VALUES ($1, $2) 
ON CONFLICT (chat_id) DO UPDATE SET title = EXCLUDED.title
`

type SetTaskInProgressNameParams struct {
	ChatID int64       `json:"chat_id"`
	Title  pgtype.Text `json:"title"`
}

func (q *Queries) SetTaskInProgressName(ctx context.Context, arg *SetTaskInProgressNameParams) error {
	_, err := q.db.Exec(ctx, setTaskInProgressName, arg.ChatID, arg.Title)
	return err
}

const setTaskInProgressUser = `-- name: SetTaskInProgressUser :exec
INSERT INTO tasks_in_progress (chat_id, executor_contact, executor_chat_id) VALUES ($1, $2, $3) 
ON CONFLICT (chat_id) DO UPDATE SET executor_contact = EXCLUDED.executor_contact, executor_chat_id = EXCLUDED.executor_chat_id
`

type SetTaskInProgressUserParams struct {
	ChatID          int64       `json:"chat_id"`
	ExecutorContact pgtype.Text `json:"executor_contact"`
	ExecutorChatID  pgtype.Int8 `json:"executor_chat_id"`
}

func (q *Queries) SetTaskInProgressUser(ctx context.Context, arg *SetTaskInProgressUserParams) error {
	_, err := q.db.Exec(ctx, setTaskInProgressUser, arg.ChatID, arg.ExecutorContact, arg.ExecutorChatID)
	return err
}
